@compiler >= 7

include "./interfaces/IAEX141.aes"
include "./interfaces/IAEX141NFTReceiver.aes"
include "./interfaces/IAENSWrapping.aes"

include "Pair.aes"

main contract AENSWrapping : IAEX141, IAENSWrapping =

    datatype metadata_type = URL | OBJECT_ID | MAP
    datatype metadata = MetadataIdentifier(string) | MetadataMap(map(string, string))

    record meta_info = 
        { name: string
        , symbol: string
        , base_url: option(string)
        , metadata_type : metadata_type }

    record config = 
        { reward: int
        , reward_block_window: int
        , emergency_reward: int
        , emergency_reward_block_window : int
        , can_receive_from_others : bool }

    record state =
        { owner: address
        , meta_info: meta_info
        , token_to_owners: map(int, address)
        , owners_to_tokens: map(address, Set.set(int))
        , names_to_token_and_owner: map(string, int * address)
        , balances: map(address, int)
        , approvals: map(int, address)
        , operators: map(address, map(address, bool))
        , metadata: map(int, metadata)
        , total_supply: int
        , counter: int }

    datatype event
        = Transfer(address, address, int)
        | Approval(address, address, int, string)
        | ApprovalForAll(address, address, string)
        // extension "mintable"
        | Mint(address, int)
        // extension "burnable"
        | Burn(address, int)

    stateful entrypoint init() =
        { owner = Contract.creator,
          meta_info = { name = "Wrapped AENS", symbol = "WAENS", base_url = None, metadata_type = MAP },
          token_to_owners = {},
          owners_to_tokens = {},
          names_to_token_and_owner = {},
          balances = {},
          approvals = {},
          operators = {},
          metadata = {},
          total_supply = 0,
          counter = 1 }

    entrypoint aex141_extensions() : list(string) =
        ["mintable", "burnable"]

    entrypoint meta_info() : meta_info =
        state.meta_info

    entrypoint metadata(token_id: int) : option(metadata) =
        Map.lookup(token_id, state.metadata)

    entrypoint total_supply() : int =
        state.total_supply

    entrypoint balance(owner: address) : option(int) =
        Map.lookup(owner, state.balances)

    entrypoint owner(token_id: int) : option(address) =
        Map.lookup(token_id, state.token_to_owners)

    stateful entrypoint transfer(to: address, token_id: int, data: option(string)) =
        let from = require_authorized(token_id)
        require(from != to, "SENDER_MUST_NOT_BE_RECEIVER")
        remove_approval(token_id)
        put(state{ balances[from] @balance1 = balance1 - 1
            , balances[to = 0] @balance2 = balance2 + 1
            , token_to_owners[token_id] = to
            , owners_to_tokens[from] @from_tokens = Set.delete(token_id, from_tokens)
            , owners_to_tokens[to = Set.new()] @to_tokens = Set.insert(token_id, to_tokens) })
        switch(invoke_nft_receiver(Some(from), to, token_id, data))
            (true, false) => abort("SAFE_TRANSFER_FAILED")
            _ => Chain.event(Transfer(from, to, token_id))

    stateful entrypoint transfer_to_contract(token_id: int) =
        let to = Call.caller
        require(Address.is_contract(to), "CALLER_MUST_BE_A_CONTRACT")
        let from = require_authorized(token_id)
        require(from != to, "SENDER_MUST_NOT_BE_RECEIVER")
        remove_approval(token_id)
        put(state{ balances[from] @balance1 = balance1 - 1
            , balances[to = 0] @balance2 = balance2 + 1
            , token_to_owners[token_id] = to
            , owners_to_tokens[from] @from_tokens = Set.delete(token_id, from_tokens)
            , owners_to_tokens[to = Set.new()] @to_tokens = Set.insert(token_id, to_tokens) })
        Chain.event(Transfer(from, to, token_id))

    stateful entrypoint approve(approved: address, token_id: int, enabled: bool) =
        require_authorized(token_id)
        if(enabled)
            put(state{approvals[token_id] = approved})
        else
            remove_approval(token_id)
        Chain.event(Approval(Call.caller, approved, token_id, bool_to_string(enabled)))

    stateful entrypoint approve_all(operator: address, enabled: bool) =
        put(state{operators @ ops = ops{[Call.caller = {}] @ op = op{[operator] = enabled}}})
        Chain.event(ApprovalForAll(Call.caller, operator, bool_to_string(enabled)))

    entrypoint get_approved(token_id: int) : option(address) =
        Map.lookup(token_id, state.approvals)

    entrypoint is_approved(token_id: int, a: address) : bool =
        switch(Map.lookup(token_id, state.approvals))
            None => false
            Some(o) => o == a

    entrypoint is_approved_for_all(owner: address, operator: address) : bool =
        switch(Map.lookup(owner, state.operators))
            None => false
            Some(ops) =>
                switch(Map.lookup(operator, ops))
                    None => false
                    Some(v) => v

    // mintable extension

    stateful entrypoint mint(to: address, metadata: option(metadata), data: option(string)) : int =
        switch(metadata)
            None =>
                mint_internal(to, data)
            Some(_) => abort("MINTING_WITH_METADATA_NOT_ALLOWED")

    // burnable extension

    stateful entrypoint burn(token_id: int) =
        let owner = require_authorized(token_id)
        remove_approval(token_id)
        put(state{ balances[owner] @balance = balance - 1
            , total_supply = state.total_supply - 1
            , token_to_owners = Map.delete(token_id, state.token_to_owners)
            , owners_to_tokens[owner] @owners_tokens = Set.delete(token_id, owners_tokens) })
        Chain.event(Burn(owner, token_id))

    // AENSWrapping

    /// @notice returns the account address of the real owner
    /// @param name the name to lookup
    /// @return real owner
    entrypoint resolve_owner(name: string) : option(address) =
        switch(Map.lookup(name, state.names_to_token_and_owner))
            Some(v) => Some(Pair.snd(v))
            None => None

    /// @notice returns the nft id where the AENS name is wrapped into
    /// @param name the name to lookup
    /// @return nft_id
    entrypoint resolve_nft_id(name: string) : option(int) =
        switch(Map.lookup(name, state.names_to_token_and_owner))
            Some(v) => Some(Pair.fst(v))
            None => None

    /// @notice returns the nft id where the AENS name is wrapped into as well as the real owner of the name
    /// @param name the name to lookup
    /// @return nft_id and owner
    entrypoint resolve_nft_id_and_owner(name: string) : option(int * address) =
        Map.lookup(name, state.names_to_token_and_owner)

    /// @notice wraps AENS names into a fresh minted NFT, adds NFT metadata, extends all names
    /// @param names_delegation_sigs a map (key = AENS name, value = delegation signature)
    /// @return the NFT id
    stateful entrypoint wrapAndMint(names_delegation_sigs: map(string, signature)) : int =
        let token_id = mint_internal(Call.caller, None)
        let names_delegation_sigs_list: list(string * signature) = Map.to_list(names_delegation_sigs)
        List.foreach(names_delegation_sigs_list, (val) => claim_and_assign(val, token_id))
        token_id

    /// @notice wraps a single AENS name into an existing NFT, adds NFT metadata, updates expiry of name to match expiry of already wrapped names
    /// @param nft_id the id of the NFT to wrap the AENS name into
    /// @param name the AENS name to wrap
    /// @param delegation_sig the delegation signature for the name
    stateful entrypoint wrapSingle(nft_id: int, name: string, delegation_sig: signature) =
      // TODO
      ()

    /// @notice wraps multiple AENS names into an existing NFT, adds NFT metadata, updates expiry of names to match expiry of already wrapped names
    /// @param nft_id the id of the NFT to wrap the AENS name into
    /// @param names_delegation_sigs a map (key = AENS name, value = delegation signature)
    stateful entrypoint wrapMultiple(nft_id: int, names_delegation_sigs: map(string, signature)) =
      // TODO
      ()

    /// @notice adds / replaces a pointer of the AENS name while keeping existing pointers
    /// @param nft_id the id of the NFT where the AENS name is wrapped into
    /// @param name the AENS name where the pointer will be added / replaced
    /// @param pointer_key the key of the pointer
    /// @param pointer_value the object to point to (account, channel, contract, oracle)
    stateful entrypoint addPointer(nft_id: int, name: string, pointer_key: string, pointer_value: AENS.pointee) =
      // TODO
      ()

    /// @notice adds / replaces a set of pointers of the AENS name
    /// @param nft_id the id of the NFT where the AENS name is wrapped into
    /// @param name the AENS name where the pointer will be added / replaced
    /// @param pointers a map of pointers to set
    /// @param keep_existing a bool indicating whether to keep existing pointers or not
    stateful entrypoint addPointers(nft_id: int, name: string, pointers: map(string, AENS.pointee), keep_existing: bool) =
      // TODO
      ()

    /// @notice removes a pointer of the AENS name
    /// @param nft_id the id of the NFT where the AENS name is wrapped into
    /// @param name the AENS name where the pointer will be removed
    /// @param pointer_key the key of the pointer
    stateful entrypoint removePointer(nft_id: int, name: string, pointer_key: string) =
      // TODO
      ()

    /// @notice removes multiple pointers of the AENS name
    /// @param nft_id the id of the NFT where the AENS name is wrapped into
    /// @param name the AENS name where the pointers will be removed
    /// @param pointer_keys a set of pointer keys
    stateful entrypoint removePointers(nft_id: int, name: string, pointer_keys: Set.set(string)) =
      // TODO
      ()

    /// @notice removes all pointers of the AENS name
    /// @param nft_id the id of the NFT where the AENS name is wrapped into
    /// @param name the AENS name where the pointers will be removed
    stateful entrypoint removeAllPointers(nft_id: int, name: string) =
      // TODO
      ()

    /// @notice revokes a single AENS name wrapped in the NFT, removes metadata
    /// @param nft_id the id of the NFT where the AENS name is wrapped into
    /// @param name the AENS name to revoke
    stateful entrypoint revokeSingle(nft_id: int, name: string) =
      // TODO
      ()

    /// @notice revokes multiple AENS names wrapped in the NFT, removes metadata
    /// @param nft_id the id of the NFT where the AENS name is wrapped into
    /// @param names the AENS names to revoke
    stateful entrypoint revokeMultiple(nft_id: int, names: Set.set(string)) =
      // TODO
      ()

    /// @notice revokes all AENS names wrapped in the NFT, removes metadata and burns the NFT
    /// @param nft_id the id of the NFT where the AENS name is wrapped into
    stateful entrypoint revokeAll(nft_id: int) =
      // TODO
      ()

    /// @notice transfers a single AENS name to another NFT by updating metadata of both NFTs, updates expiry of name to match expiry of already wrapped names
    /// @param nft_id_old the id of the NFT that currently wraps the AENS name
    /// @param nft_id_new the id of the NFT that will wrap the AENS name in the future
    /// @param name the AENS name to transfer
    stateful entrypoint transferSingle(nft_id_old: int, nft_id_new: int, name: string) =
      // TODO
      ()

    /// @notice transfers multiple AENS names to another NFT by updating metadata of both NFTs, updates expiry of names to match expiry of already wrapped names
    /// @param nft_id_old the id of the NFT that currently wraps the AENS name
    /// @param nft_id_new the id of the NFT that will wrap the AENS name in the future
    /// @param names the AENS names to transfer
    stateful entrypoint transferMultiple(nft_id_old: int, nft_id_new: int, names: Set.set(string)) =
      // TODO
      ()

    /// @notice transfers a single AENS name to another NFT by updating metadata of both NFTs, updates expiry of names to match expiry of already wrapped names, burns the old NFT
    /// @param nft_id_old the id of the NFT that currently wraps the AENS name
    /// @param nft_id_new the id of the NFT that will wrap the AENS name in the future
    stateful entrypoint transferAll(nft_id_old: int, nft_id_new: int) =
      // TODO
      ()

    /// @notice claims the transfer of a single AENS name to another NFT, requires the current owner to provide the delegation signature off-chain to the owner of the target NFT, updates expiry of name to match expiry of already wrapped names
    /// @param nft_id_old the id of the NFT that currently wraps the AENS name
    /// @param nft_id_new the id of the NFT that will wrap the AENS name in the future
    /// @param name the AENS name to transfer
    /// @param delegation_sig the delegation signature for the name provided by the owner of nft_id_old
    stateful entrypoint claimSingleTransfer(nft_id_old: int, nft_id_new: int, name: string, delegation_sig: signature) =
      // TODO
      ()

    /// @notice claims the transfer of a single AENS name to another NFT, requires the current owner to provide the delegation signatures off-chain to the owner of the target NFT, updates expiry of names to match expiry of already wrapped names
    /// @param nft_id_old the id of the NFT that currently wraps the AENS name
    /// @param nft_id_new the id of the NFT that will wrap the AENS name in the future
    /// @param names_delegation_sigs a map (key = AENS name, value = delegation signature)
    stateful entrypoint claimMultipleTransfer(nft_id_old: int, nft_id_new: int, names_delegation_sigs: map(string, signature)) =
      // TODO
      ()

    /// @notice transfers the AENS name back to the owner or to another defined recipient, updates metadata
    /// @param nft_id the id of the NFT that currently wraps the AENS name
    /// @param name the AENS name to transfer
    /// @param recipient the address that should receive the AENS name
    stateful entrypoint unwrapSingle(nft_id: int, name: string, recipient: option(address)) =
      // TODO
      ()

    /// @notice transfers the AENS names back to the owner or to another defined recipient, updates metadata
    /// @param nft_id the id of the NFT that currently wraps the AENS name
    /// @param names the AENS names to transfer
    /// @param recipient the address that should receive the AENS name
    stateful entrypoint unwrapMultiple(nft_id: int, names: Set.set(string), recipient: option(address)) =
      // TODO
      ()

    /// @notice transfers all AENS names back to the owner or to another defined recipient, updates metadata, burns the NFT
    /// @param nft_id the id of the NFT that currently wraps the AENS name
    /// @param recipient the address that should receive the AENS name
    stateful entrypoint unwrapAll(nft_id: int, recipient: option(address)) =
      // TODO
      ()

    /// @notice caller sets global config for NFTs owned by the caller
    /// @param config the global config
    stateful entrypoint setGlobalConfig(config: config) =
      // TODO
      ()

    /// @notice caller removes global config for NFTs owned by the caller
    stateful entrypoint removeGlobalConfig() =
      // TODO
      ()

    /// @notice caller sets NFT specific config
    /// @param nft_id the id of the NFT to set the config
    /// @param config the nft specific config
    stateful entrypoint setNftConfig(nft_id: int, config: config) =
      // TODO
      ()

    /// @notice caller removes NFT specific config
    /// @param nft_id the id of the NFT to remove the config from
    stateful entrypoint removeNftConfig(nft_id: int) =
      // TODO
      ()

    /// @notice caller deposits AE to his reward pool
    stateful entrypoint depositToRewardPool() =
      // TODO
      ()

    /// @notice caller withdraws all AE or a specific amount from his reward pool
    /// @param amount the optional amount of AE to withdraw
    stateful entrypoint withdrawFromRewardPool(amount: option(int)) =
      // TODO
      ()

    /// @notice calculates the reward based on the expiration date of the names wrapped in an NFT, considering the global config (or the NFT specific config if set) and the amount of Æ deposited by the NFT owner
    /// @param nft_id the id of the NFT to extend
    /// @return the estimated reward
    entrypoint estimateReward(nft_id: int) =
      0

    /// @notice extends all AENS names wrapped in the NFT without getting a reward
    /// @param nft_id the id of the NFT that wraps the AENS names to extend
    stateful entrypoint extendAll(nft_id: int) =
      // TODO
      ()

    /// @notice extends all AENS names wrapped in the NFT and distributes a reward to the caller
    /// @param nft_id the id of the NFT that wraps the AENS names to extend
    stateful entrypoint extendAllForReward(nft_id: int) =
      // TODO
      ()

    /// @notice transfers a set of NFTs to the desired recipient
    /// @param recipient the address to become new owner of the NFTs
    /// @param nft_ids the ids of the NFTs to transfer
    stateful entrypoint transferMultipleNfts(recipient: address, nft_ids: Set.set(int)) =
      // TODO
      ()

    /// @notice burns a set of NFTs (only possible if AENS names are expired)
    /// @param nft_ids the ids of the NFTs to burn
    stateful entrypoint burnMultipleNfts(nft_ids: Set.set(int)) =
      // TODO
      ()

    // external helpers for AEX-141

    entrypoint get_owned_tokens(owner: address) : list(int) =
        Set.to_list(Map.lookup_default(owner, state.owners_to_tokens, Set.new()))

    // internal helper functions

    function get_metadata_map(metadata: metadata) : map(string, string) =
      switch(metadata)
          MetadataMap(v) => v

    function require_caller_is_receipient(recipient: address) =
        require(Call.caller == recipient, "CALLER_MUST_BE_RECIPIENT")

    function require_authorized(token_id: int) : address =
        let owner = switch(owner(token_id))
            None => abort("TOKEN_NOT_EXISTS")
            Some(v) => v
        require(Call.caller == owner || is_approved(token_id, Call.caller) || is_approved_for_all(owner, Call.caller), "ONLY_OWNER_APPROVED_OR_OPERATOR_CALL_ALLOWED")
        owner

    function is_token_owner(token_id: int, a: address) : bool =
        switch(Map.lookup(token_id, state.token_to_owners))
            None => false
            Some(o) => o == a

    stateful function claim_and_assign(name_delegation_sig: string * signature, token_id: int) =
        let name = Pair.fst(name_delegation_sig)
        AENS.transfer(Call.caller, Contract.address, name, signature = Pair.snd(name_delegation_sig))
        let nft_metadata_map = get_metadata_map(Map.lookup_default(token_id, state.metadata, MetadataMap({})))
        // adding name to the MetadataMap (value is irrelevant)
        let updated_map = nft_metadata_map{[name] @ n = ""}
        put(state{ metadata[token_id = MetadataMap({})] @nft_metadata = MetadataMap(updated_map) })
        put(state{ names_to_token_and_owner[name] @token_owner = (token_id, Call.caller) })

    stateful function mint_internal(to: address, data: option(string)) : int =
        require_caller_is_receipient(to)
        let token_id = state.counter
        put(state{ counter = state.counter + 1
            , total_supply = state.total_supply + 1
            , balances[to = 0] @balance = balance + 1
            , token_to_owners[token_id] = to
            , owners_to_tokens[to = Set.new()] @owners_tokens = Set.insert(token_id, owners_tokens)})
        switch(invoke_nft_receiver(None, to, token_id, data))
            (true, false) => abort("SAFE_TRANSFER_FAILED")
            _ => Chain.event(Mint(to, token_id))
        token_id

    stateful function remove_approval(token_id: int) =
        if(Map.member(token_id, state.approvals))
            put(state{ approvals = Map.delete(token_id, state.approvals) })

    stateful function burn_internal(owner: address, token_id: int) =
        put(state{ balances[owner] @owner_balance = owner_balance - 1
            , total_supply = state.total_supply - 1
            , token_to_owners = Map.delete(token_id, state.token_to_owners)
            , owners_to_tokens[owner] @owners_tokens = Set.delete(token_id, owners_tokens) })

    function invoke_nft_receiver(from: option(address), to: address, token_id: int, data: option(string)) : (bool * bool) =
        if(Address.is_contract(to))
            let c = Address.to_contract(to)
            switch(c.on_aex141_received(from, token_id, data, protected = true) : option(bool))
                None => (true, false)
                Some(val) => (true, val)
        else
            (false, false)

    function bool_to_string(v: bool): string =
        switch (v)
            true => "true"
            false => "false"