{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The work in this repository is part of a grant approved by the \u00e6ternity crypto foundation.</p>"},{"location":"#before-the-grant-status-quo","title":"Before the grant (status quo)","text":"<ul> <li>No batch actions (updates, transfers) for AENS names are possible</li> <li>No trading of AENS names possible</li> <li>Users still suffer from name expiration as they fail to consistently track name expiration</li> </ul>"},{"location":"#after-the-grant-result-of-this-work","title":"After the grant (result of this work)","text":"<p>Wrapping AENS names into NFTs will make it easy to perform batch-actions on the names and enable new use cases. NFT trading is also highly anticipated and is another topic to tackle in that regards.</p> <p>The results of the work in this grant will:</p> <ul> <li>provide a way for the community to better manage their AENS names</li> <li>enable batch-actions for AENS names</li> <li>allow strangers to extend AENS names and get rewarded for that</li> <li>make AENS names easily tradable on NFT marketplaces</li> </ul>"},{"location":"#simple-explainer","title":"Simple explainer","text":"<p>By calling the entrypoint <code>wrap_and_mint</code>, users can wrap up to 50 AENS names (<code>name_limit</code> configured during deployment of the contract) into an NFT.</p> <p>The AENSWrapping contract syncs the expiration of all wrapped AENS names by extending all of them with the <code>max_name_ttl</code> (configured during deployment of the contract).</p> <p></p> <p>Every user can:</p> <ul> <li>create as many NFTs as they want and thus wrap as many AENS names as they want</li> <li>wrap/unwrap AENS names into/from existing NFTs that they own</li> <li>add or replace pointer(s) of a specific AENS name that is wrapped into an NFT that they own</li> <li>revoke AENS names that are wrapped into NFTs that they own</li> <li>transfer NFTs (and thus also the wrapped AENS names) to other users</li> <li>define a global config to define:<ul> <li>reward (incl. reward block window) for other users for extending their names</li> <li>emergency-reward (incl. emergency reward block window) for other users for extending their names</li> <li>if other users can transfer AENS names into NFTs that they own</li> <li>if other users can burn NFTs that they own in case they are empty</li> </ul> </li> <li>define a similar config for each NFT they own (overrrules the global config)</li> <li>deposit AE to the reward pool in order to reward other users for extending their names</li> <li>withdraw of AE from the reward pool</li> <li>extend all AENS names wrapped into a specific NFT (no matter if they own it or not) by calling:<ul> <li><code>extend_all</code> (no reward, good will)</li> <li><code>extend_all_for_reward</code> (rewards the user in case there is a reward configured, the reward block window is reached and the owner of the NFT has AE deposited to the reward pool)</li> </ul> </li> </ul>"},{"location":"#full-example-sequence","title":"Full example sequence","text":"<pre><code>sequenceDiagram\n    actor AENS / NFT owner\n\n    AENS / NFT owner -&gt;&gt; AENSWrapping (NFT Contract): 1) wrap_and_mint\n    Note left of AENSWrapping (NFT Contract): claims ownership of names&lt;br /&gt;mints NFT with id 1&lt;br /&gt;assigns names to NFT&lt;br /&gt;extends all AENS names\n    AENSWrapping (NFT Contract) --&gt;&gt; AENS / NFT owner: assign ownership of NFT with id 1\n\n    actor User XY\n\n    User XY -&gt;&gt; AENSWrapping (NFT Contract): 2) extend_all: nft_id (1)\n    Note right of AENSWrapping (NFT Contract): extends all AENS names wrapped in the given NFT&lt;br /&gt; user does not get any reward\n\n    AENS / NFT owner -&gt;&gt; AENSWrapping (NFT Contract): 3) set_global_config: config\n    Note left of AENSWrapping (NFT Contract): can enable global rewards for extending names&lt;br /&gt;in NFTs owned by the caller according to the config&lt;br /&gt;reward = 50 \u00c6&lt;br /&gt;reward_block_window = 480&lt;br /&gt;emergency_reward = 100 \u00c6&lt;br /&gt;emergency_reward_block_window = 10&lt;br /&gt;can_receive_from_others = false&lt;br /&gt;burnable_if_empty = false\n\n    AENS / NFT owner -&gt;&gt; AENSWrapping (NFT Contract): 4) deposit_to_reward_pool\n    AENS / NFT owner --&gt;&gt; AENSWrapping (NFT Contract): 500 \u00c6\n    Note left of AENSWrapping (NFT Contract): adds 500 \u00c6 to reward pool of NFT owner\n\n    User XY -&gt;&gt; AENSWrapping (NFT Contract): 5) extend_all: nft_id (1)\n    Note right of AENSWrapping (NFT Contract): extends all AENS names wrapped in the given NFT&lt;br /&gt; user does not get any reward&lt;br /&gt; can be called anytime\n\n    User XY -&gt;&gt; AENSWrapping (NFT Contract): 6) extend_all_for_reward: nft_id (1)\n    AENSWrapping (NFT Contract) --&gt;&gt; User XY: 50 \u00c6\n    Note right of AENSWrapping (NFT Contract): extends all AENS names wrapped in the given NFT&lt;br /&gt; only rewards if called 480 blocks before the names expire\n    Note right of AENSWrapping (NFT Contract): deducts 50 \u00c6 from reward pool of NFT owner&lt;br /&gt;new value: 450 \u00c6\n\n    AENS / NFT owner -&gt;&gt; AENSWrapping (NFT Contract): 7) wrap_and_mint\n    Note left of AENSWrapping (NFT Contract): claims ownership of names&lt;br /&gt;mints NFT with id 2&lt;br /&gt;assigns names to NFT&lt;br /&gt;extends all AENS names\n    AENSWrapping (NFT Contract) --&gt;&gt; AENS / NFT owner: assign ownership of NFT with id 2\n\n    AENS / NFT owner -&gt;&gt; AENSWrapping (NFT Contract): 8) set_nft_config: nft_id (2), config\n    Note left of AENSWrapping (NFT Contract): provide NFT specific config&lt;br /&gt;reward = 350 \u00c6&lt;br /&gt;reward_block_window = 2400&lt;br /&gt;emergency_reward = 500 \u00c6&lt;br /&gt;emergency_reward_block_window = 480&lt;br /&gt;can_receive_from_others = false&lt;br /&gt;burnable_if_empty = false\n\n    User XY -&gt;&gt; AENSWrapping (NFT Contract): 9) extend_all_for_reward: nft_id (2)\n    AENSWrapping (NFT Contract) --&gt;&gt; User XY: 450 \u00c6\n    Note right of AENSWrapping (NFT Contract): emergency reward within the 480 block before expiration\n    Note right of AENSWrapping (NFT Contract): deducts 450 \u00c6 from reward pool of NFT owner&lt;br /&gt;new value: 0 \u00c6\n    Note right of AENSWrapping (NFT Contract): normally 500 \u00c6 would have been paid, but only 450 are left in the reward pool of the NFT owner \n\n    AENS / NFT owner -&gt;&gt; AENSWrapping (NFT Contract): 10) transfer_single: nft_id_old (1), nft_id_new (2), name\n    Note left of AENSWrapping (NFT Contract): associates provided name to nft with id 2&lt;br /&gt;updates expiry of transferred name to match expiry of names in NFT with id 2\n\n    AENS / NFT owner -&gt;&gt; AENSWrapping (NFT Contract): 11) add_or_replace_pointer: nft_id, name, pointer_key, pointer_object\n    Note left of AENSWrapping (NFT Contract): adds or replaces pointer for specific name wrapped in NFT\n\n    AENS / NFT owner -&gt;&gt; AENSWrapping (NFT Contract): 12) unwrap_all: nft_id (1), none\n    AENSWrapping (NFT Contract) --&gt;&gt; AENS / NFT owner: transfer of all AENS names wrapped in NFT with id 1\n\n    AENS / NFT owner -&gt;&gt; AENSWrapping (NFT Contract): 13) unwrap_all: nft_id (2), user xy\n    AENSWrapping (NFT Contract) --&gt;&gt; User XY: transfer of all AENS names wrapped in NFT with id 2</code></pre>"},{"location":"#sponsors","title":"Sponsors","text":"<p>This work is sponsored by the \u00e6ternity crypto foundation.</p> <p>Do you also wanna sponsor this work? Send some \u00c6 coins to:</p> <ul> <li><code>buymeacoffee.chain</code> or</li> <li><code>ak_3mw4DAv1mbo8XbEjTgt8UgWTgGJoNmiRnvCywz4BD6192kHtm</code></li> </ul>"},{"location":"contract-interface/","title":"Contract Interface","text":""},{"location":"contract-interface/#iaex141","title":"IAEX141","text":"<pre><code>contract interface IAEX141 =\ndatatype metadata_type = URL | OBJECT_ID | MAP\ndatatype metadata = MetadataIdentifier(string) | MetadataMap(map(string, string))\n\nrecord meta_info = { name: string\n, symbol: string\n, base_url: option(string)\n, metadata_type : metadata_type }\n\ndatatype event\n= Transfer(address, address, int)\n| Approval(address, address, int, string)\n| ApprovalForAll(address, address, string)\n// extension \"mintable\"\n| Mint(address, int)\n// extension \"burnable\"\n| Burn(address, int)\n\nentrypoint aex141_extensions : () =&gt; list(string)\nentrypoint meta_info : () =&gt; meta_info\nentrypoint metadata : (int) =&gt; option(metadata)\nentrypoint total_supply : () =&gt; int\nentrypoint balance : (address) =&gt; option(int)\nentrypoint owner : (int) =&gt; option(address)  stateful entrypoint transfer : (address, int, option(string)) =&gt; unit\nstateful entrypoint transfer_to_contract : (int) =&gt; unit\nstateful entrypoint approve : (address, int, bool) =&gt; unit\nstateful entrypoint approve_all : (address, bool) =&gt; unit\nentrypoint get_approved : (int) =&gt; option(address)\nentrypoint is_approved : (int, address) =&gt; bool\nentrypoint is_approved_for_all : (address, address) =&gt; bool\n\n// extension \"mintable\"\nstateful entrypoint mint : (address, option(metadata), option(string)) =&gt; int\n\n// extension \"burnable\"\nstateful entrypoint burn : (int) =&gt; unit\n</code></pre>"},{"location":"contract-interface/#iaenswrapping","title":"IAENSWrapping","text":"<pre><code>contract interface IAENSWrapping : IAEX141 =\n\ndatatype event\n// name, nft_id, owner, new_ttl\n= NameWrap(string, int, address, int)\n// name, nft_id, current_owner, recipient\n| NameUnwrap(string, int, address, address)\n// name, nft_id, new_ttl, caller\n| NameExtend(string, int, int, address)\n// name, nft_id_old, nft_id_new\n| NameTransfer(string, int, int)\n// name, nft_id\n| NameRevoke(string, int)\n// nft_id, caller, reward\n| Reward(int, address, int)\n// authorized_deployer\n| MigrationTargetDeployerSet(address)\n| MigrationTargetDeployerUnset()\n// ceres_contract_address\n| MigrationActivation(address)\n// nft_id, wrapped_names_count, owner\n| Migrate(int, int, address)\n\nrecord nft_data =\n{ id: int\n, owner: address\n, owner_config: option(config)\n, names: list(string)\n, expiration_height: int }\n\nrecord config =\n{ reward: int\n, reward_block_window: int\n, emergency_reward: int\n, emergency_reward_block_window: int\n, can_receive_from_others: bool\n, burnable_if_empty: bool }\n\nrecord migration_data =\n{ names: list(string)\n, expiration_height: Chain.ttl }\n\n/// @notice returns the account address of the real owner\n/// @param name the name to lookup\n/// @return real owner\nentrypoint resolve_owner : (string) =&gt; option(address)\n\n/// @notice returns the nft id where the AENS name is wrapped into\n/// @param name the name to lookup\n/// @return nft_id\nentrypoint resolve_nft_id : (string) =&gt; option(int)\n\n/// @notice returns the nft id where the AENS name is wrapped into as well as the real owner of the name\n/// @param name the name to lookup\n/// @return nft_id and owner\nentrypoint resolve_nft_id_and_owner : (string) =&gt; option(int * address)\n\n/// @notice returns the nft id where the AENS name is wrapped into as well as the real owner of the name\n/// @param nft_id the NFT id\n/// @return nft_data\nentrypoint get_nft_data : (string) =&gt; option(nft_data)\n\n/// @notice returns the expiration height of names that are wrapped into the provided nft id\n/// @param nft_id the NFT id\n/// @return the (fixed) height where all names wrapped into the nft will expire\nentrypoint get_expiration_by_nft_id : (int) =&gt; option(int)\n\n/// @notice returns the global config for an account\n/// @param account the account address to lookup the config for\n/// @return the global config for an account OR None if not set\nentrypoint get_global_config : (address) =&gt; option(config)\n\n/// @notice returns the balance included in the reward pool\n/// @param account the account where the reward pool balance should be looked up for\n/// @return the reward pool balance\nentrypoint get_reward_pool : (address) =&gt; int\n\n/// @notice returns the total reward that has been distributed for extending names with this contract\n/// @return total_reward_distributed\nentrypoint get_total_reward_distributed : () =&gt; int\n\n/// @notice wraps AENS names into a fresh minted NFT, adds NFT metadata, extends all names\n/// @param names_delegation_sigs a map (key = AENS name, value = delegation signature)\n/// @return the NFT id\nstateful entrypoint wrap_and_mint : (map(string, signature)) =&gt; int\n\n/// @notice wraps a single AENS name into an existing NFT, adds NFT metadata, updates expiry of name to match expiry of already wrapped names\n/// @param nft_id the id of the NFT to wrap the AENS name into\n/// @param name the AENS name to wrap\n/// @param delegation_sig the delegation signature for the name\nstateful entrypoint wrap_single : (int, string, signature) =&gt; unit\n\n/// @notice wraps multiple AENS names into an existing NFT, adds NFT metadata, updates expiry of names to match expiry of already wrapped names\n/// @param nft_id the id of the NFT to wrap the AENS name into\n/// @param names_delegation_sigs a map (key = AENS name, value = delegation signature)\nstateful entrypoint wrap_multiple : (int, map(string, signature)) =&gt; unit\n\n/// @notice adds / replaces a pointer of the AENS name while keeping existing pointers\n/// @param nft_id the id of the NFT where the AENS name is wrapped into\n/// @param name the AENS name where the pointer will be added / replaced\n/// @param key the key of the pointer\n/// @param pt the object to point to (account, channel, contract, oracle)\nstateful entrypoint add_or_replace_pointer : (int, string, string, AENS.pointee) =&gt; unit\n\n/// @notice adds / replaces a set of pointers of the AENS name\n/// @param nft_id the id of the NFT where the AENS name is wrapped into\n/// @param name the AENS name where the pointers will be added / replaced\n/// @param pointers a map of pointers to set\n/// @param keep_existing a bool indicating whether to keep existing pointers or not\nstateful entrypoint add_or_replace_pointers : (int, string, map(string, AENS.pointee), bool) =&gt; unit\n\n/// @notice removes a pointer of the AENS name\n/// @param nft_id the id of the NFT where the AENS name is wrapped into\n/// @param name the AENS name where the pointer will be removed\n/// @param key the key of the pointer\nstateful entrypoint remove_pointer : (int, string, string) =&gt; unit\n\n/// @notice removes multiple pointers of the AENS name\n/// @param nft_id the id of the NFT where the AENS name is wrapped into\n/// @param name the AENS name where the pointers will be removed\n/// @param keys a set of pointer keys\nstateful entrypoint remove_pointers : (int, string, Set.set(string)) =&gt; unit\n\n/// @notice removes all pointers of the AENS name\n/// @param nft_id the id of the NFT where the AENS name is wrapped into\n/// @param name the AENS name where the pointers will be removed\nstateful entrypoint remove_all_pointers : (int, string) =&gt; unit\n\n/// @notice revokes a single AENS name wrapped in the NFT, removes metadata\n/// @param nft_id the id of the NFT where the AENS name is wrapped into\n/// @param name the AENS name to revoke\nstateful entrypoint revoke_single : (int, string) =&gt; unit\n\n/// @notice revokes multiple AENS names wrapped in the NFT, removes metadata\n/// @param nft_id the id of the NFT where the AENS name is wrapped into\n/// @param names the AENS names to revoke\nstateful entrypoint revoke_multiple : (int, Set.set(string)) =&gt; unit\n\n/// @notice revokes all AENS names wrapped in the NFT, removes metadata\n/// @param nft_id the id of the NFT where the AENS name is wrapped into\nstateful entrypoint revoke_all : (int) =&gt; unit\n\n/// @notice transfers a single AENS name to another NFT by updating metadata of both NFTs, updates expiry of name to match expiry of already wrapped names\n/// @param nft_id_old the id of the NFT that currently wraps the AENS name\n/// @param nft_id_new the id of the NFT that will wrap the AENS name in the future\n/// @param name the AENS name to transfer\nstateful entrypoint transfer_single : (int, int, string) =&gt; unit\n\n/// @notice transfers multiple AENS names to another NFT by updating metadata of both NFTs, updates expiry of names to match expiry of already wrapped names\n/// @param nft_id_old the id of the NFT that currently wraps the AENS name\n/// @param nft_id_new the id of the NFT that will wrap the AENS name in the future\n/// @param names the AENS names to transfer\nstateful entrypoint transfer_multiple : (int, int, Set.set(string)) =&gt; unit\n\n/// @notice transfers a single AENS name to another NFT by updating metadata of both NFTs, updates expiry of names to match expiry of already wrapped names\n/// @param nft_id_old the id of the NFT that currently wraps the AENS name\n/// @param nft_id_new the id of the NFT that will wrap the AENS name in the future\nstateful entrypoint transfer_all : (int, int) =&gt; unit\n\n/// @notice transfers the AENS name back to the owner or to another defined recipient, updates metadata\n/// @param nft_id the id of the NFT that currently wraps the AENS name\n/// @param name the AENS name to transfer\n/// @param recipient the address that should receive the AENS name\nstateful entrypoint unwrap_single : (int, string, option(address)) =&gt; unit\n\n/// @notice transfers the AENS names back to the owner or to another defined recipient, updates metadata\n/// @param nft_id the id of the NFT that currently wraps the AENS name\n/// @param names the AENS names to transfer\n/// @param recipient the address that should receive the AENS name\nstateful entrypoint unwrap_multiple : (int, Set.set(string), option(address)) =&gt; unit\n\n/// @notice transfers all AENS names back to the owner or to another defined recipient, updates metadata\n/// @param nft_id the id of the NFT that currently wraps the AENS name\n/// @param recipient the address that should receive the AENS name\nstateful entrypoint unwrap_all : (int, option(address)) =&gt; unit\n\n/// @notice caller sets global config for NFTs owned by the caller\n/// @param config the global config\nstateful entrypoint set_global_config : (config) =&gt; unit\n\n/// @notice caller removes global config for NFTs owned by the caller\nstateful entrypoint remove_global_config : () =&gt; unit\n\n/// @notice caller sets NFT specific config\n/// @param nft_id the id of the NFT to set the config\n/// @param config the nft specific config\nstateful entrypoint set_nft_config : (int, config) =&gt; unit\n\n/// @notice caller removes NFT specific config\n/// @param nft_id the id of the NFT to remove the config from\nstateful entrypoint remove_nft_config : (int) =&gt; unit\n\n/// @notice caller deposits AE to his reward pool\nstateful payable entrypoint deposit_to_reward_pool : () =&gt; unit\n\n/// @notice caller withdraws all AE or a specific amount from his reward pool\n/// @param amount the optional amount of AE to withdraw\nstateful entrypoint withdraw_from_reward_pool : (option(int)) =&gt; unit\n\n/// @notice calculates the reward based on the expiration date of the names wrapped in an NFT, considering the global config (or the NFT specific config if set) and the amount of \u00c6 deposited by the NFT owner\n/// @param nft_id the id of the NFT to extend\n/// @return the estimated reward\nentrypoint estimate_reward : (int) =&gt; int\n\n/// @notice extends all AENS names wrapped in the NFT without getting a reward\n/// @param nft_id the id of the NFT that wraps the AENS names to extend\nstateful entrypoint extend_all : (int) =&gt; unit\n\n/// @notice extends all AENS names wrapped in the NFT and distributes a reward to the caller\n/// @param nft_id the id of the NFT that wraps the AENS names to extend\nstateful entrypoint extend_all_for_reward : (int) =&gt; unit\n\n/// @notice transfers a set of NFTs to the desired recipient\n/// @param recipient the address to become new owner of the NFTs\n/// @param nft_ids the ids of the NFTs to transfer\n/// @param data optional data to be provided to a contract receiver\nstateful entrypoint transfer_multiple_nfts : (address, Set.set(int), option(string)) =&gt; unit\n\n/// @notice burns a set of NFTs (only possible if AENS names are expired)\n/// @param nft_ids the ids of the NFTs to burn\nstateful entrypoint burn_multiple_nfts : (Set.set(int)) =&gt; unit\n\n/// @notice returns the address of the admin that can set the contract address of the future ceres contract to handle the migration\nentrypoint get_admin : () =&gt; address\n\n/// @notice returns the address of the admin OR an alternative address that can be defined by the admin for deployment of the target contract\nentrypoint get_migration_target_deployer : () =&gt; address\n\n/// @notice defines an address which will be authorized to deploy the contract that activates the migration\n/// @param deployer the address that shall be authorized\nstateful entrypoint set_migration_target_deployer : (address) =&gt; unit\n\n/// @notice returns the address of the target ceres contract that users can use to perform a migration to\n/// @return the address of the target ceres contract that is allowed to trigger an NFT migration OR None if migration is not activated yet\nentrypoint get_migration_target : () =&gt; option(address)\n\n/// @notice activates the migration which can be triggered with an updated target contract after ceres protocol upgrade. entrypoint can only be called by the deployer address via deployment of the target contract\nstateful entrypoint activate_migration : () =&gt; unit\n\n/// @notice migrates &amp; burns an NFT from this contract to the ceres contract (can only be executed by the NFT owner via an entrypoint in the ceres contract)\n/// @param nft_id the id of the NFT to migrate &amp; burn\n/// @return the migration data that the ceres contract needs set the correct internal state\nstateful entrypoint migrate : (int) =&gt; migration_data\n</code></pre>"},{"location":"ideation-mindmap/","title":"Ideation Mindmap","text":""},{"location":"sponsors/","title":"Sponsors","text":"<p>This work is sponsored by the \u00e6ternity crypto foundation.</p> <p>Do you also wanna sponsor this work? Send some \u00c6 coins to:</p> <ul> <li><code>buymeacoffee.chain</code> or</li> <li><code>ak_3mw4DAv1mbo8XbEjTgt8UgWTgGJoNmiRnvCywz4BD6192kHtm</code></li> </ul>"},{"location":"diagrams/burn_nfts/","title":"Explicit Burn of NFTs","text":"<p>Note:</p> <ul> <li>Burning NFTs is only possible if the wrapped AENS names are expired OR if the NFT is empty, meaning it does not wrap an AENS name</li> <li>The burn entrypoint is part of the AEX-141 standard and can be called by any user</li> <li>If the config of the NFT owner allows it, anybody can burn the NFT</li> </ul>"},{"location":"diagrams/burn_nfts/#single","title":"Single","text":"<pre><code>sequenceDiagram\n    actor Any user\n    Any user -&gt;&gt; NFT Contract: 1) burn: nft_id\n    Note left of NFT Contract: default burn entrypoint of AEX-141\n    Note left of NFT Contract: removes all data associated with the NFT\n    Note left of NFT Contract: burns the NFT</code></pre>"},{"location":"diagrams/burn_nfts/#multiple","title":"Multiple","text":"<pre><code>sequenceDiagram\n    actor Any user\n    Any user -&gt;&gt; NFT Contract: 1) burn_multiple_nfts: Set(nft_id)\n    Note left of NFT Contract: removes all data associated with the NFTs\n    Note left of NFT Contract: burns the NFTs</code></pre>"},{"location":"diagrams/extend_aens_names/","title":"Extend AENS names","text":""},{"location":"diagrams/extend_aens_names/#for-free","title":"For free","text":"<pre><code>sequenceDiagram\n    actor Any user\n    Any user -&gt;&gt; NFT Contract: 1) extend_all: nft_id\n    Note left of NFT Contract: extends all wrapped AENS names of the given NFT</code></pre>"},{"location":"diagrams/extend_aens_names/#for-reward","title":"For reward","text":"<pre><code>sequenceDiagram\n    actor Any user\n    Any user -&gt;&gt; NFT Contract: 1) extend_all_for_reward: nft_id\n    Note left of NFT Contract: extends all wrapped AENS names of the given NFT\n    NFT Contract --&gt;&gt; Any user: 2) send AE\n    Note left of NFT Contract: use amount of reward specified by NFT owner</code></pre>"},{"location":"diagrams/revoke_aens_names/","title":"Revoke AENS names","text":""},{"location":"diagrams/revoke_aens_names/#single-name","title":"Single name","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) revoke_single: nft_id, name\n    Note left of NFT Contract: revokes AENS name wrapped in the NFT\n    Note left of NFT Contract: removes association of name to NFT</code></pre> <p>Considerations</p> <ul> <li>How to reward users for extending?</li> </ul>"},{"location":"diagrams/revoke_aens_names/#multiple-names","title":"Multiple names","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) revoke_multiple: nft_id, Set(names)\n    Note left of NFT Contract: revokes AENS names wrapped in the NFT\n    Note left of NFT Contract: removes association of names to NFT</code></pre> <p>Considerations</p> <ul> <li>How to reward users for extending?</li> </ul>"},{"location":"diagrams/revoke_aens_names/#all-names","title":"All names","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) revoke_all: nft_id\n    Note left of NFT Contract: revokes AENS names wrapped in the NFT\n    Note left of NFT Contract: burns the NFT and removes all data associated to it</code></pre>"},{"location":"diagrams/reward_users/","title":"Reward users for extending names","text":"<p>By default, rewarding users for extending names wrapped in NFTs will not be activated.</p> <p>For rewarding, we distinguish between a global reward config and an NFT specific reward config. This allows users to provide higher rewards for specific NFTs that contain AENS names which they consider more valuable than others and vice versa.</p> <p>The global config is defined by an account and will be applied on all NFTs this account owns.</p> <p>NFT specific config always overrules the global reward-config.</p> <p>When an NFT is transferred to another account, the NFT specific reward-config will be removed.</p>"},{"location":"diagrams/reward_users/#config","title":"Config","text":"<ul> <li><code>reward</code> the amount of \u00c6 (in \u00e6ttos) to be distributed, if a user extends names wrapped in an NFT in the regular <code>reward_block_window</code></li> <li><code>reward_block_window</code> the window (in keyblocks) before name expiration where the defined <code>reward</code> is paid</li> <li><code>emergency_reward</code> the amount of \u00c6 (in \u00e6ttos) to be distributed, if a user extends names wrapped in an NFT in the <code>emergency_reward_block_window</code></li> <li><code>emergency_reward_block_window</code> the window (in keyblocks) before name expiration where the defined <code>emergency_reward</code> is paid</li> <li><code>can_receive_from_others</code> defines if a users allows his NFTs to receive and wrap AENS names from others</li> <li><code>burnable_if_empty</code></li> </ul> <p>Note</p> <ul> <li><code>estimate_reward</code> entrypoint calculates the reward based on the expiration date of the names wrapped in an NFT, considering the global config (or the NFT specific config if set) and the amount of \u00c6 deposited by the NFT owner</li> <li>in case the deposited \u00c6 amount of the NFT owner is lower than <code>reward</code> or <code>emergency_reward</code>, the remaining \u00c6 are returned</li> </ul>"},{"location":"diagrams/reward_users/#set-global-config","title":"Set global config","text":"<pre><code>sequenceDiagram\n    actor Any user\n    Any user -&gt;&gt; NFT Contract: 1) set_global_config: config\n    Note left of NFT Contract: activates rewarding based on provided config</code></pre>"},{"location":"diagrams/reward_users/#remove-global-config","title":"Remove global config","text":"<pre><code>sequenceDiagram\n    actor Any user\n    Any user -&gt;&gt; NFT Contract: 1) remove_global_config\n    Note left of NFT Contract: deactivates rewarding by removing the config</code></pre>"},{"location":"diagrams/reward_users/#set-nft-specific-config","title":"Set NFT specific config","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) set_nft_config: nft_id, config\n    Note left of NFT Contract: activates NFT specific config</code></pre>"},{"location":"diagrams/reward_users/#remove-nft-specific-reward-config","title":"Remove NFT specific reward config","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) remove_nft_config: nft_id\n    Note left of NFT Contract: deactivates NFT specific config</code></pre>"},{"location":"diagrams/reward_users/#deposit-to-reward-pool","title":"Deposit to reward pool","text":"<pre><code>sequenceDiagram\n    actor Any user\n    Any user -&gt;&gt; NFT Contract: 1) deposit_to_reward_pool\n    Note left of NFT Contract: adds the amount of \u00e6ttos sent to the reward pool of an account</code></pre>"},{"location":"diagrams/reward_users/#withdraw-reward-balance","title":"Withdraw reward balance","text":"<pre><code>sequenceDiagram\n    actor Any user\n    Any user -&gt;&gt; NFT Contract: 1) withdraw_from_reward_pool: option(amount)\n    Note left of NFT Contract: removes the provided amount (\u00e6ttios) from the reward pool of an account\n    Note left of NFT Contract: if no amount is provided, the complete balance in reward pool will be withdrawn</code></pre>"},{"location":"diagrams/transfer_aens_names/","title":"Transfer AENS names","text":""},{"location":"diagrams/transfer_aens_names/#single-name","title":"Single name","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) transfer_single: nft_id_old, nft_id_new, name\n    Note left of NFT Contract: requires caller to be owner of both NFTs\n    Note left of NFT Contract: changes association of name from one NFT to another NFT\n    Note left of NFT Contract: updates expiry of transferred name to match expiry of names in nft_id_new</code></pre>"},{"location":"diagrams/transfer_aens_names/#multiple-names","title":"Multiple names","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) transfer_multiple: nft_id_old, nft_id_new, Set(names)\n    Note left of NFT Contract: requires caller to be owner of both NFTs\n    Note left of NFT Contract: changes association of names from one NFT to another NFT\n    Note left of NFT Contract: updates expiry of transferred names to match expiry of names in nft_id_new</code></pre>"},{"location":"diagrams/transfer_aens_names/#all-names","title":"All names","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) transfer_all: nft_id_old, nft_id_new\n    Note left of NFT Contract: requires caller to be owner of both NFTs\n    Note left of NFT Contract: changes association of name from one NFT to another NFT\n    Note left of NFT Contract: updates expiry of transferred names to match expiry of names in nft_id_new\n    Note left of NFT Contract: burns the old NFT</code></pre> <p>Note:</p> <ul> <li>Users can define via config on a global or NFT specific level if they want to allow receiving AENS names from others<ul> <li>By default this is not allowed to prevent spamming NFTs with (unwanted) AENS names</li> </ul> </li> </ul>"},{"location":"diagrams/transfer_nfts/","title":"Transfer NFTs","text":""},{"location":"diagrams/transfer_nfts/#single","title":"Single","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) transfer: recipient, nft_id, option(data)\n    Note left of NFT Contract: default transfer entrypoint of AEX-141</code></pre>"},{"location":"diagrams/transfer_nfts/#multiple","title":"Multiple","text":"<pre><code>sequenceDiagram\n    actor Any user\n    Any user -&gt;&gt; NFT Contract: 1) transfer_multiple_nfts: recipient, Set(nft_id), option(data)</code></pre>"},{"location":"diagrams/unwrap_aens_names/","title":"Unwrap AENS names","text":""},{"location":"diagrams/unwrap_aens_names/#single-name","title":"Single name","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) unwrap_single: nft_id, name, option(recipient)\n    NFT Contract --&gt;&gt; NFT owner: 1.1) transfer name</code></pre>"},{"location":"diagrams/unwrap_aens_names/#multiple-names","title":"Multiple names","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) unwrap_multiple: nft_id, Set(names), option(recipient)\n    NFT Contract --&gt;&gt; NFT owner: 1.1) transfer names</code></pre>"},{"location":"diagrams/unwrap_aens_names/#all-names","title":"All names","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) unwrap_all: nft_id, option(recipient)\n    NFT Contract --&gt;&gt; NFT owner: 1.1) transfer names</code></pre> <p>Note:</p> <ul> <li>If no recipient is defined, the names will be returned to the owner of the NFT calling the unwrap entrypoint</li> </ul>"},{"location":"diagrams/update_pointers/","title":"Update pointers of AENS names","text":""},{"location":"diagrams/update_pointers/#add-a-single-pointer","title":"Add a single pointer","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) add_or_replace_pointer: nft_id, name, pointer_key, pointer_object\n    Note left of NFT Contract: keeps other existing pointers\n    Note left of NFT Contract: adds or replaces a single pointer of the provided name</code></pre>"},{"location":"diagrams/update_pointers/#add-a-set-of-pointers","title":"Add a set of pointers","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) add_or_replace_pointers: nft_id, name, map(pointer_key, pointer_object), keep_existing\n    Note left of NFT Contract: keeps other existing pointers only if keep_existing=true\n    Note left of NFT Contract: adds or replaces pointers of the provided name</code></pre>"},{"location":"diagrams/update_pointers/#remove-a-single-pointer","title":"Remove a single pointer","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) remove_pointer: nft_id, name, pointer_key\n    Note left of NFT Contract: keeps other existing pointers\n    Note left of NFT Contract: removes the provided pointer of the provided name</code></pre>"},{"location":"diagrams/update_pointers/#remove-multiple-pointers","title":"Remove multiple pointers","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) remove_pointers: nft_id, name, Set(pointer_key)\n    Note left of NFT Contract: keeps other existing pointers\n    Note left of NFT Contract: removes the provided pointers of the provided name</code></pre>"},{"location":"diagrams/update_pointers/#remove-all-pointers","title":"Remove all pointers","text":"<pre><code>sequenceDiagram\n    actor NFT owner\n    NFT owner -&gt;&gt; NFT Contract: 1) remove_all_pointers: nft_id, name\n    Note left of NFT Contract: removes the provided pointer of the provided name</code></pre>"},{"location":"diagrams/wrap_aens_names/","title":"Wrap AENS names","text":""},{"location":"diagrams/wrap_aens_names/#wrap-names-by-minting-a-new-nft","title":"Wrap names by minting a new NFT","text":"<pre><code>sequenceDiagram\n    actor AENS owner\n    AENS owner -&gt;&gt; NFT Contract: 1) wrap_and_mint: map(name, delegation_signature)\n    Note left of NFT Contract: claims ownership of names\n    Note left of NFT Contract: mints NFT\n    Note left of NFT Contract: assigns names to NFT\n    Note left of NFT Contract: extends all names\n    NFT Contract --&gt;&gt; AENS owner: 1.1) assign ownership of NFT</code></pre>"},{"location":"diagrams/wrap_aens_names/#iris-protocol-limitation","title":"Iris protocol limitation","text":"<ul> <li>Delegation signature needs to be created in advance for each AENS name.<ul> <li>With the future Ceres protocol upgrade, it will be possible to give a contract permission to handle all AENS names owned by an account, see: https://github.com/aeternity/aeternity/issues/4080</li> </ul> </li> </ul>"},{"location":"diagrams/wrap_aens_names/#wrap-name-into-existing-nft","title":"Wrap name into existing NFT","text":"<pre><code>sequenceDiagram\n    actor AENS owner\n    AENS owner -&gt;&gt; NFT Contract: 1) wrap_single: nft_id, name, delegation_signature\n    Note left of NFT Contract: claims ownership of name\n    Note left of NFT Contract: assigns name to NFT\n    Note left of NFT Contract: updates expiry of name to wrap to match expiry of names in nft_id</code></pre>"},{"location":"diagrams/wrap_aens_names/#wrap-multiple-names-into-existing-nft","title":"Wrap multiple names into existing NFT","text":"<pre><code>sequenceDiagram\n    actor AENS owner\n    AENS owner -&gt;&gt; NFT Contract: 1) wrap_multiple: nft_id, map(name, delegation_signature)\n    Note left of NFT Contract: claims ownership of names\n    Note left of NFT Contract: assigns names to NFT\n    Note left of NFT Contract: updates expiry of names to wrap to match expiry of names in nft_id</code></pre>"}]}